/*
 * @Description: In User Settings Edit
 * @Author: your name
 * @Date: 2019-09-06 16:37:13
 * @LastEditTime: 2019-09-06 16:46:21
 * @LastEditors: Please set LastEditors
 */

/**
 * 0.1+0.2 为什么不等于0.3
 * 
 */
//  在定点数中，如果我们以8位二进制来存储数字。
//  对于整数来说，十进制的35会被存储为： 00100011 其代表 2^5 + 2^1 + 2^0。
//  对于纯小数来说，十进制的0.375会被存储为： 0.011 其代表 1/2^2 + 1/2^3 = 1/4 + 1/8 = 0.375

// 对于像0.1这样的数值用二进制表示你就会发现无法整除，最后算下来会是 0.000110011…由于存储空间有限，
// 最后计算机会舍弃后面的数值，所以我们最后就只能得到一个近似值。
// 在存储空间有限的情况下，当出现这种无法整除的小数的时候就会取一个近似值，在js中如果这个近似值足够近似，那么js就会认为他就是那个值。

// 除了那些能表示成 x/2^n 的数可以被精确表示以外，其余小数都是以近似值得方式存在的。

// 在0.1 + 0.2这个式子中，0.1和0.2都是近似表示的，
// 在他们相加的时候，两个近似值进行了计算，导致最后得到的值是0.30000000000000004，
// 此时对于JS来说，其不够近似于0.3，于是就出现了0.1 + 0.2 != 0.3 这个现象。 
// 当然，也并非所有的近似值相加都得不到正确的结果。

// 正确处理办法是
Number.parseFloat((0.1 + 0.2).toFixed(10)) // 0.3
